<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monkey and Hunter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        .ejc-credit-banner {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            color: white;
            padding: 12px 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            position: sticky;
            top: 0;
            z-index: 10000;
        }
        
        .ejc-credit-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .ejc-credit-title {
            font-size: 16px;
            font-weight: 600;
        }
        
        .ejc-credit-author {
            font-size: 14px;
            opacity: 0.95;
        }
        
        .ejc-credit-author strong {
            font-weight: 600;
            color: #fbbf24;
        }
    </style>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        /* Custom scrollbar for controls */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
    </style>
</head>
<body>
    <div class="ejc-credit-banner">
        <div class="ejc-credit-content">
            <div class="ejc-credit-title">Monkey and Hunter</div>
            <div class="ejc-credit-author">Created by <strong>Seetoh Huixia</strong> | EJC Physics</div>
        </div>
    </div>
    
    <div class="ejc-simulation-container">
        

    <!-- Canvas Area -->
    <div class="relative flex-grow h-[60vh] md:h-full bg-slate-900 overflow-hidden" id="canvas-container">
        <canvas id="simCanvas"></canvas>
        
        <!-- Overlay Messages -->
        <div id="statusMessage" class="absolute top-4 left-1/2 transform -translate-x-1/2 bg-slate-800/80 backdrop-blur px-6 py-2 rounded-full text-white font-semibold shadow-lg border border-slate-700 opacity-0 transition-opacity duration-300 pointer-events-none">
            Hit!
        </div>

        <!-- Legend -->
        <div class="absolute top-4 left-4 bg-slate-800/80 backdrop-blur p-4 rounded-lg border border-slate-700 text-xs text-slate-300 pointer-events-none hidden sm:block">
            <div class="flex items-center mb-1"><span class="w-3 h-3 rounded-full bg-slate-500 border border-slate-400 mr-2"></span> Hunter</div>
            <div class="flex items-center mb-1"><span class="w-3 h-3 rounded-full bg-yellow-400 mr-2"></span> Projectile</div>
            <div class="flex items-center mb-1"><span class="w-3 h-3 rounded-full bg-red-500 mr-2"></span> Target (Monkey)</div>
            <div class="flex items-center"><span class="w-8 h-0.5 bg-green-500/50 border-t border-dashed border-green-500 mr-2"></span> Line of Sight</div>
        </div>
    </div>

    <!-- Controls Sidebar -->
    <div class="w-full md:w-80 bg-slate-800 border-l border-slate-700 flex flex-col shadow-xl z-10 overflow-y-auto">
        <div class="p-6">
            <h1 class="text-2xl font-bold text-white mb-2">Monkey & Hunter</h1>
            <p class="text-slate-400 text-sm mb-6">
                A classic kinematics problem. The hunter aims directly at the monkey. At the moment the gun is fired, the monkey drops. Will the bullet hit?
            </p>

            <!-- Main Actions -->
            <div class="flex gap-3 mb-8">
                <button id="fireBtn" class="flex-1 bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg shadow-lg shadow-blue-900/50 transition-all transform active:scale-95">
                    FIRE
                </button>
                <button id="resetBtn" class="flex-1 bg-slate-700 hover:bg-slate-600 text-white font-bold py-3 px-4 rounded-lg border border-slate-600 transition-all transform active:scale-95">
                    RESET
                </button>
            </div>

            <!-- Sliders -->
            <div class="space-y-6">
                <!-- Gun Angle -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-sm font-medium text-slate-300">Gun Angle</label>
                        <span id="angleVal" class="text-sm font-mono text-blue-400">0?</span>
                    </div>
                    <div id="angleControlGroup" class="transition-opacity">
                        <input type="range" id="angleRange" min="0" max="90" value="0" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-blue-500">
                    </div>
                </div>

                <!-- Velocity -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-sm font-medium text-slate-300">Bullet Velocity</label>
                        <span id="speedVal" class="text-sm font-mono text-blue-400">150 m/s</span>
                    </div>
                    <input type="range" id="speedRange" min="50" max="300" value="150" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-blue-500">
                </div>

                <!-- Distance -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-sm font-medium text-slate-300">Distance</label>
                        <span id="distVal" class="text-sm font-mono text-blue-400">600 m</span>
                    </div>
                    <input type="range" id="distRange" min="200" max="800" value="600" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-blue-500">
                </div>

                <!-- Height -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-sm font-medium text-slate-300">Monkey Height</label>
                        <span id="heightVal" class="text-sm font-mono text-blue-400">400 m</span>
                    </div>
                    <input type="range" id="heightRange" min="100" max="600" value="400" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-blue-500">
                </div>
            </div>

            <!-- Toggles -->
            <div class="mt-8 space-y-3">
                <label class="flex items-center space-x-3 cursor-pointer group">
                    <input type="checkbox" id="autoAimCheck" class="form-checkbox h-5 w-5 text-blue-600 rounded bg-slate-700 border-slate-600 focus:ring-blue-500 focus:ring-offset-slate-800">
                    <span class="text-slate-300 group-hover:text-white transition-colors">Auto-Aim (Lock)</span>
                </label>
                <label class="flex items-center space-x-3 cursor-pointer group">
                    <input type="checkbox" id="slowMotionCheck" class="form-checkbox h-5 w-5 text-blue-600 rounded bg-slate-700 border-slate-600 focus:ring-blue-500 focus:ring-offset-slate-800">
                    <span class="text-slate-300 group-hover:text-white transition-colors">Slow Motion</span>
                </label>
                <label class="flex items-center space-x-3 cursor-pointer group">
                    <input type="checkbox" id="showTrailsCheck" checked class="form-checkbox h-5 w-5 text-blue-600 rounded bg-slate-700 border-slate-600 focus:ring-blue-500 focus:ring-offset-slate-800">
                    <span class="text-slate-300 group-hover:text-white transition-colors">Show Trails</span>
                </label>
                <label class="flex items-center space-x-3 cursor-pointer group">
                    <input type="checkbox" id="showSightCheck" checked class="form-checkbox h-5 w-5 text-blue-600 rounded bg-slate-700 border-slate-600 focus:ring-blue-500 focus:ring-offset-slate-800">
                    <span class="text-slate-300 group-hover:text-white transition-colors">Show Aim Line</span>
                </label>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        
        // UI Elements
        const fireBtn = document.getElementById('fireBtn');
        const resetBtn = document.getElementById('resetBtn');
        const speedRange = document.getElementById('speedRange');
        const distRange = document.getElementById('distRange');
        const heightRange = document.getElementById('heightRange');
        const angleRange = document.getElementById('angleRange');
        const autoAimCheck = document.getElementById('autoAimCheck');
        const angleControlGroup = document.getElementById('angleControlGroup');
        
        const speedVal = document.getElementById('speedVal');
        const distVal = document.getElementById('distVal');
        const heightVal = document.getElementById('heightVal');
        const angleVal = document.getElementById('angleVal');
        
        const slowMotionCheck = document.getElementById('slowMotionCheck');
        const showTrailsCheck = document.getElementById('showTrailsCheck');
        const showSightCheck = document.getElementById('showSightCheck');
        const statusMessage = document.getElementById('statusMessage');

        // State
        let animationId = null;
        let isFiring = false;
        let simulationTime = 0;
        let lastTimestamp = 0;
        let currentAngleRad = 0;
        
        // Physics Configuration
        const GRAVITY = 9.81 * 40; // Scaled for pixels
        let bulletV0 = 150 * 5; // Scaled
        let monkeyDist = 600;
        let monkeyHeight = 400;
        
        // Entity Positions
        let hunterPos = { x: 100, y: 0 }; // y is set in resize
        let monkeyPos = { x: 0, y: 0 };
        let bulletPos = { x: 0, y: 0 };
        let monkeyStartPos = { x: 0, y: 0 };
        
        // Trails
        let bulletTrail = [];
        let monkeyTrail = [];

        // Canvas Sizing
        function resize() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            hunterPos.y = canvas.height - 50;
            resetSimulation();
        }
        window.addEventListener('resize', resize);

        // Update UI Values
        function updateValues(e) {
            // Values from sliders are abstract, we scale them for the canvas
            bulletV0 = parseInt(speedRange.value) * 6; 
            monkeyDist = parseInt(distRange.value);
            // Height is inverted for UI (higher value = higher up)
            monkeyHeight = parseInt(heightRange.value);

            // Handle Aiming Logic
            if (autoAimCheck.checked) {
                // Calculate perfect angle
                const dx = monkeyDist;
                const dy = monkeyHeight; // Positive because we use it for calculation, though canvas Y is flipped
                currentAngleRad = Math.atan2(dy, dx);
                
                // Update disabled slider visual
                const deg = (currentAngleRad * 180 / Math.PI).toFixed(1);
                angleRange.value = deg;
                angleVal.innerText = deg + "?";
                
                // Disable input
                angleRange.disabled = true;
                angleRange.classList.add('cursor-not-allowed');
                angleControlGroup.classList.add('opacity-50');
            } else {
                // Manual Aim
                // Read from slider
                currentAngleRad = parseFloat(angleRange.value) * Math.PI / 180;
                
                angleVal.innerText = angleRange.value + "?";
                
                // Enable input
                angleRange.disabled = false;
                angleRange.classList.remove('cursor-not-allowed');
                angleControlGroup.classList.remove('opacity-50');
            }

            speedVal.innerText = speedRange.value + " m/s";
            distVal.innerText = distRange.value + " m";
            heightVal.innerText = heightRange.value + " m";
            
            if (!isFiring) {
                resetSimulation();
            }
        }

        [speedRange, distRange, heightRange, angleRange, autoAimCheck].forEach(el => el.addEventListener('input', updateValues));

        // Simulation Control
        function resetSimulation() {
            cancelAnimationFrame(animationId);
            isFiring = false;
            simulationTime = 0;
            bulletTrail = [];
            monkeyTrail = [];
            
            // Set initial positions
            // Monkey x is relative to hunter
            monkeyPos.x = hunterPos.x + monkeyDist;
            // Monkey y is height above ground (canvas.height - 50)
            monkeyPos.y = hunterPos.y - monkeyHeight;
            monkeyStartPos = { ...monkeyPos };
            
            bulletPos = { ...hunterPos };
            
            fireBtn.disabled = false;
            fireBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            fireBtn.innerText = "FIRE";
            
            statusMessage.style.opacity = '0';
            
            draw();
        }

        function startSimulation() {
            if (isFiring) return;
            isFiring = true;
            lastTimestamp = performance.now();
            fireBtn.disabled = true;
            fireBtn.classList.add('opacity-50', 'cursor-not-allowed');
            fireBtn.innerText = "FIRING...";
            animate(lastTimestamp);
        }

        function animate(timestamp) {
            if (!isFiring) return;

            const dt = (timestamp - lastTimestamp) / 1000;
            lastTimestamp = timestamp;

            // Time scaling
            const timeScale = slowMotionCheck.checked ? 0.2 : 1.0;
            simulationTime += dt * timeScale;

            // Calculate Physics
            // Angle is now fixed at start of fire based on currentAngleRad
            // Invert angle for canvas coordinate system (up is negative Y)
            const angle = -currentAngleRad; 

            // 2. Bullet Position
            // x = v0 * cos(theta) * t
            // y = v0 * sin(theta) * t + 0.5 * g * t^2
            bulletPos.x = hunterPos.x + (bulletV0 * Math.cos(angle) * simulationTime);
            bulletPos.y = hunterPos.y + (bulletV0 * Math.sin(angle) * simulationTime) + (0.5 * GRAVITY * simulationTime * simulationTime);

            // 3. Monkey Position
            // x = constant
            // y = y0 + 0.5 * g * t^2
            monkeyPos.y = monkeyStartPos.y + (0.5 * GRAVITY * simulationTime * simulationTime);

            // Record trails
            if (simulationTime > 0 && simulationTime < 10) { // Limit trail length check
                if (bulletTrail.length === 0 || Math.hypot(bulletPos.x - bulletTrail[bulletTrail.length-1].x, bulletPos.y - bulletTrail[bulletTrail.length-1].y) > 5) {
                    bulletTrail.push({ ...bulletPos });
                }
                if (monkeyTrail.length === 0 || Math.abs(monkeyPos.y - monkeyTrail[monkeyTrail.length-1].y) > 5) {
                    monkeyTrail.push({ ...monkeyPos });
                }
            }

            // Collision Detection
            const dist = Math.hypot(bulletPos.x - monkeyPos.x, bulletPos.y - monkeyPos.y);
            const hitThreshold = 30; // Radius sum roughly

            // Ground Hit Detection
            if (bulletPos.y > canvas.height - 50 || monkeyPos.y > canvas.height - 50) {
                isFiring = false;
                fireBtn.innerText = "MISSED / GROUND";
                statusMessage.innerText = "Missed!";
                statusMessage.classList.remove('text-green-400');
                statusMessage.classList.add('text-red-400');
                statusMessage.style.opacity = '1';
            }
            
            // Hit Detection
            if (dist < hitThreshold) {
                isFiring = false;
                fireBtn.innerText = "HIT!";
                statusMessage.innerText = "Target Hit!";
                statusMessage.classList.remove('text-red-400');
                statusMessage.classList.add('text-green-400');
                statusMessage.style.opacity = '1';
                
                // Snap to exact collision for visual clarity
                bulletPos.x = monkeyPos.x;
                bulletPos.y = monkeyPos.y;
            }

            draw();

            if (isFiring) {
                animationId = requestAnimationFrame(animate);
            }
        }

        // Drawing Logic
        function draw() {
            // Clear Background
            ctx.fillStyle = '#0f172a'; // Slate 900
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Ground
            ctx.fillStyle = '#1e293b'; // Slate 800
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
            ctx.strokeStyle = '#334155';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 50);
            ctx.lineTo(canvas.width, canvas.height - 50);
            ctx.stroke();

            // Draw Grid (Optional subtle background)
            drawGrid();
            
            // Draw Dimensions (New)
            drawDimensions();

            // Draw Aim Line
            if (showSightCheck.checked) {
                ctx.save();
                ctx.strokeStyle = 'rgba(34, 197, 94, 0.3)'; // Green low opacity
                ctx.setLineDash([10, 10]);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(hunterPos.x, hunterPos.y);
                
                // Calculate line end based on current angle, not just monkey pos (incase manual aim)
                const lineLen = 2000;
                const endX = hunterPos.x + Math.cos(-currentAngleRad) * lineLen;
                const endY = hunterPos.y + Math.sin(-currentAngleRad) * lineLen;
                
                ctx.lineTo(endX, endY);
                ctx.stroke();
                ctx.restore();
            }

            // Draw Trails
            if (showTrailsCheck.checked) {
                // Bullet Trail
                ctx.save();
                ctx.strokeStyle = 'rgba(250, 204, 21, 0.4)'; // Yellow
                ctx.lineWidth = 2;
                ctx.beginPath();
                if (bulletTrail.length > 0) {
                    ctx.moveTo(bulletTrail[0].x, bulletTrail[0].y);
                    for (let p of bulletTrail) ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                }
                
                // Monkey Trail
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.4)'; // Red
                ctx.beginPath();
                if (monkeyTrail.length > 0) {
                    ctx.moveTo(monkeyTrail[0].x, monkeyTrail[0].y);
                    for (let p of monkeyTrail) ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // Draw Hunter (Cannon)
            drawHunter();

            // Draw Monkey
            drawMonkey(monkeyPos.x, monkeyPos.y);

            // Draw Bullet
            if (isFiring || bulletTrail.length > 0) {
                ctx.fillStyle = '#fbbf24'; // Amber 400
                ctx.shadowColor = '#fbbf24';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(bulletPos.x, bulletPos.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function drawGrid() {
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 1;
            const gridSize = 50;
            
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawDimensions() {
            ctx.save();
            ctx.strokeStyle = '#94a3b8'; // Slate 400
            ctx.fillStyle = '#94a3b8';
            ctx.font = '12px monospace';
            ctx.lineWidth = 1;

            // Draw Distance Line (Horizontal)
            const groundY = canvas.height - 25; // Middle of ground
            ctx.beginPath();
            ctx.moveTo(hunterPos.x, groundY);
            ctx.lineTo(monkeyStartPos.x, groundY);
            ctx.stroke();
            
            // Ticks
            ctx.beginPath();
            ctx.moveTo(hunterPos.x, groundY - 5);
            ctx.lineTo(hunterPos.x, groundY + 5);
            ctx.moveTo(monkeyStartPos.x, groundY - 5);
            ctx.lineTo(monkeyStartPos.x, groundY + 5);
            ctx.stroke();
            
            // Label
            ctx.textAlign = 'center';
            ctx.fillText(`Distance: ${monkeyDist}m`, (hunterPos.x + monkeyStartPos.x) / 2, groundY - 8);

            // Draw Height Line (Vertical)
            // Draw slightly to the right of the monkey so it doesn't overlap trails too much
            const lineX = monkeyStartPos.x + 40; 
            ctx.beginPath();
            ctx.moveTo(lineX, monkeyStartPos.y);
            ctx.lineTo(lineX, hunterPos.y);
            ctx.stroke();

            // Ticks
            ctx.beginPath();
            ctx.moveTo(lineX - 5, monkeyStartPos.y);
            ctx.lineTo(lineX + 5, monkeyStartPos.y);
            ctx.moveTo(lineX - 5, hunterPos.y);
            ctx.lineTo(lineX + 5, hunterPos.y);
            ctx.stroke();

            // Label
            ctx.save();
            ctx.translate(lineX + 15, (monkeyStartPos.y + hunterPos.y) / 2);
            ctx.rotate(Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText(`Height: ${monkeyHeight}m`, 0, 0);
            ctx.restore();

            ctx.restore();
        }

        function drawHunter() {
            const size = 40;
            ctx.save();
            ctx.translate(hunterPos.x, hunterPos.y);
            
            // Rotation based on current Angle state
            ctx.rotate(-currentAngleRad); // Negative because canvas Y is down

            // Cannon Barrel
            ctx.fillStyle = '#475569';
            ctx.fillRect(0, -10, 60, 20);
            
            // Cannon Rim
            ctx.fillStyle = '#334155';
            ctx.fillRect(55, -12, 10, 24);

            ctx.restore();

            // Base/Wheel
            ctx.fillStyle = '#1e293b';
            ctx.beginPath();
            ctx.arc(hunterPos.x, hunterPos.y, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Label
            ctx.fillStyle = '#cbd5e1'; 
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText("HUNTER", hunterPos.x, hunterPos.y + 35);
        }

        function drawMonkey(x, y) {
            // Draw Target/Monkey
            ctx.save();
            ctx.translate(x, y);

            // Body
            ctx.fillStyle = '#ef4444'; // Red 500
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();
            
            // Face detail (simple)
            ctx.fillStyle = '#fca5a5'; // Red 200
            ctx.beginPath();
            ctx.arc(0, 2, 14, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#7f1d1d';
            ctx.beginPath();
            ctx.arc(-5, -2, 3, 0, Math.PI * 2);
            ctx.arc(5, -2, 3, 0, Math.PI * 2);
            ctx.fill();

            // Mouth
            ctx.beginPath();
            ctx.arc(0, 6, 4, 0, Math.PI, false);
            ctx.stroke();

            ctx.restore();
        }

        // Listeners
        fireBtn.addEventListener('click', startSimulation);
        resetBtn.addEventListener('click', resetSimulation);
        slowMotionCheck.addEventListener('change', () => {
             // Real-time toggle support not needed for simple sim, takes effect next frame or fire
        });
        showTrailsCheck.addEventListener('change', draw);
        showSightCheck.addEventListener('change', draw);

        // Initial setup
        resize();
        // Trigger one update to set values correctly
        updateValues();

    </script>

    </div>
    
    <script src="https://cdn.tailwindcss.com"></script>
<script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        
        // UI Elements
        const fireBtn = document.getElementById('fireBtn');
        const resetBtn = document.getElementById('resetBtn');
        const speedRange = document.getElementById('speedRange');
        const distRange = document.getElementById('distRange');
        const heightRange = document.getElementById('heightRange');
        const angleRange = document.getElementById('angleRange');
        const autoAimCheck = document.getElementById('autoAimCheck');
        const angleControlGroup = document.getElementById('angleControlGroup');
        
        const speedVal = document.getElementById('speedVal');
        const distVal = document.getElementById('distVal');
        const heightVal = document.getElementById('heightVal');
        const angleVal = document.getElementById('angleVal');
        
        const slowMotionCheck = document.getElementById('slowMotionCheck');
        const showTrailsCheck = document.getElementById('showTrailsCheck');
        const showSightCheck = document.getElementById('showSightCheck');
        const statusMessage = document.getElementById('statusMessage');

        // State
        let animationId = null;
        let isFiring = false;
        let simulationTime = 0;
        let lastTimestamp = 0;
        let currentAngleRad = 0;
        
        // Physics Configuration
        const GRAVITY = 9.81 * 40; // Scaled for pixels
        let bulletV0 = 150 * 5; // Scaled
        let monkeyDist = 600;
        let monkeyHeight = 400;
        
        // Entity Positions
        let hunterPos = { x: 100, y: 0 }; // y is set in resize
        let monkeyPos = { x: 0, y: 0 };
        let bulletPos = { x: 0, y: 0 };
        let monkeyStartPos = { x: 0, y: 0 };
        
        // Trails
        let bulletTrail = [];
        let monkeyTrail = [];

        // Canvas Sizing
        function resize() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            hunterPos.y = canvas.height - 50;
            resetSimulation();
        }
        window.addEventListener('resize', resize);

        // Update UI Values
        function updateValues(e) {
            // Values from sliders are abstract, we scale them for the canvas
            bulletV0 = parseInt(speedRange.value) * 6; 
            monkeyDist = parseInt(distRange.value);
            // Height is inverted for UI (higher value = higher up)
            monkeyHeight = parseInt(heightRange.value);

            // Handle Aiming Logic
            if (autoAimCheck.checked) {
                // Calculate perfect angle
                const dx = monkeyDist;
                const dy = monkeyHeight; // Positive because we use it for calculation, though canvas Y is flipped
                currentAngleRad = Math.atan2(dy, dx);
                
                // Update disabled slider visual
                const deg = (currentAngleRad * 180 / Math.PI).toFixed(1);
                angleRange.value = deg;
                angleVal.innerText = deg + "?";
                
                // Disable input
                angleRange.disabled = true;
                angleRange.classList.add('cursor-not-allowed');
                angleControlGroup.classList.add('opacity-50');
            } else {
                // Manual Aim
                // Read from slider
                currentAngleRad = parseFloat(angleRange.value) * Math.PI / 180;
                
                angleVal.innerText = angleRange.value + "?";
                
                // Enable input
                angleRange.disabled = false;
                angleRange.classList.remove('cursor-not-allowed');
                angleControlGroup.classList.remove('opacity-50');
            }

            speedVal.innerText = speedRange.value + " m/s";
            distVal.innerText = distRange.value + " m";
            heightVal.innerText = heightRange.value + " m";
            
            if (!isFiring) {
                resetSimulation();
            }
        }

        [speedRange, distRange, heightRange, angleRange, autoAimCheck].forEach(el => el.addEventListener('input', updateValues));

        // Simulation Control
        function resetSimulation() {
            cancelAnimationFrame(animationId);
            isFiring = false;
            simulationTime = 0;
            bulletTrail = [];
            monkeyTrail = [];
            
            // Set initial positions
            // Monkey x is relative to hunter
            monkeyPos.x = hunterPos.x + monkeyDist;
            // Monkey y is height above ground (canvas.height - 50)
            monkeyPos.y = hunterPos.y - monkeyHeight;
            monkeyStartPos = { ...monkeyPos };
            
            bulletPos = { ...hunterPos };
            
            fireBtn.disabled = false;
            fireBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            fireBtn.innerText = "FIRE";
            
            statusMessage.style.opacity = '0';
            
            draw();
        }

        function startSimulation() {
            if (isFiring) return;
            isFiring = true;
            lastTimestamp = performance.now();
            fireBtn.disabled = true;
            fireBtn.classList.add('opacity-50', 'cursor-not-allowed');
            fireBtn.innerText = "FIRING...";
            animate(lastTimestamp);
        }

        function animate(timestamp) {
            if (!isFiring) return;

            const dt = (timestamp - lastTimestamp) / 1000;
            lastTimestamp = timestamp;

            // Time scaling
            const timeScale = slowMotionCheck.checked ? 0.2 : 1.0;
            simulationTime += dt * timeScale;

            // Calculate Physics
            // Angle is now fixed at start of fire based on currentAngleRad
            // Invert angle for canvas coordinate system (up is negative Y)
            const angle = -currentAngleRad; 

            // 2. Bullet Position
            // x = v0 * cos(theta) * t
            // y = v0 * sin(theta) * t + 0.5 * g * t^2
            bulletPos.x = hunterPos.x + (bulletV0 * Math.cos(angle) * simulationTime);
            bulletPos.y = hunterPos.y + (bulletV0 * Math.sin(angle) * simulationTime) + (0.5 * GRAVITY * simulationTime * simulationTime);

            // 3. Monkey Position
            // x = constant
            // y = y0 + 0.5 * g * t^2
            monkeyPos.y = monkeyStartPos.y + (0.5 * GRAVITY * simulationTime * simulationTime);

            // Record trails
            if (simulationTime > 0 && simulationTime < 10) { // Limit trail length check
                if (bulletTrail.length === 0 || Math.hypot(bulletPos.x - bulletTrail[bulletTrail.length-1].x, bulletPos.y - bulletTrail[bulletTrail.length-1].y) > 5) {
                    bulletTrail.push({ ...bulletPos });
                }
                if (monkeyTrail.length === 0 || Math.abs(monkeyPos.y - monkeyTrail[monkeyTrail.length-1].y) > 5) {
                    monkeyTrail.push({ ...monkeyPos });
                }
            }

            // Collision Detection
            const dist = Math.hypot(bulletPos.x - monkeyPos.x, bulletPos.y - monkeyPos.y);
            const hitThreshold = 30; // Radius sum roughly

            // Ground Hit Detection
            if (bulletPos.y > canvas.height - 50 || monkeyPos.y > canvas.height - 50) {
                isFiring = false;
                fireBtn.innerText = "MISSED / GROUND";
                statusMessage.innerText = "Missed!";
                statusMessage.classList.remove('text-green-400');
                statusMessage.classList.add('text-red-400');
                statusMessage.style.opacity = '1';
            }
            
            // Hit Detection
            if (dist < hitThreshold) {
                isFiring = false;
                fireBtn.innerText = "HIT!";
                statusMessage.innerText = "Target Hit!";
                statusMessage.classList.remove('text-red-400');
                statusMessage.classList.add('text-green-400');
                statusMessage.style.opacity = '1';
                
                // Snap to exact collision for visual clarity
                bulletPos.x = monkeyPos.x;
                bulletPos.y = monkeyPos.y;
            }

            draw();

            if (isFiring) {
                animationId = requestAnimationFrame(animate);
            }
        }

        // Drawing Logic
        function draw() {
            // Clear Background
            ctx.fillStyle = '#0f172a'; // Slate 900
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Ground
            ctx.fillStyle = '#1e293b'; // Slate 800
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
            ctx.strokeStyle = '#334155';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 50);
            ctx.lineTo(canvas.width, canvas.height - 50);
            ctx.stroke();

            // Draw Grid (Optional subtle background)
            drawGrid();
            
            // Draw Dimensions (New)
            drawDimensions();

            // Draw Aim Line
            if (showSightCheck.checked) {
                ctx.save();
                ctx.strokeStyle = 'rgba(34, 197, 94, 0.3)'; // Green low opacity
                ctx.setLineDash([10, 10]);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(hunterPos.x, hunterPos.y);
                
                // Calculate line end based on current angle, not just monkey pos (incase manual aim)
                const lineLen = 2000;
                const endX = hunterPos.x + Math.cos(-currentAngleRad) * lineLen;
                const endY = hunterPos.y + Math.sin(-currentAngleRad) * lineLen;
                
                ctx.lineTo(endX, endY);
                ctx.stroke();
                ctx.restore();
            }

            // Draw Trails
            if (showTrailsCheck.checked) {
                // Bullet Trail
                ctx.save();
                ctx.strokeStyle = 'rgba(250, 204, 21, 0.4)'; // Yellow
                ctx.lineWidth = 2;
                ctx.beginPath();
                if (bulletTrail.length > 0) {
                    ctx.moveTo(bulletTrail[0].x, bulletTrail[0].y);
                    for (let p of bulletTrail) ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                }
                
                // Monkey Trail
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.4)'; // Red
                ctx.beginPath();
                if (monkeyTrail.length > 0) {
                    ctx.moveTo(monkeyTrail[0].x, monkeyTrail[0].y);
                    for (let p of monkeyTrail) ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // Draw Hunter (Cannon)
            drawHunter();

            // Draw Monkey
            drawMonkey(monkeyPos.x, monkeyPos.y);

            // Draw Bullet
            if (isFiring || bulletTrail.length > 0) {
                ctx.fillStyle = '#fbbf24'; // Amber 400
                ctx.shadowColor = '#fbbf24';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(bulletPos.x, bulletPos.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function drawGrid() {
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 1;
            const gridSize = 50;
            
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawDimensions() {
            ctx.save();
            ctx.strokeStyle = '#94a3b8'; // Slate 400
            ctx.fillStyle = '#94a3b8';
            ctx.font = '12px monospace';
            ctx.lineWidth = 1;

            // Draw Distance Line (Horizontal)
            const groundY = canvas.height - 25; // Middle of ground
            ctx.beginPath();
            ctx.moveTo(hunterPos.x, groundY);
            ctx.lineTo(monkeyStartPos.x, groundY);
            ctx.stroke();
            
            // Ticks
            ctx.beginPath();
            ctx.moveTo(hunterPos.x, groundY - 5);
            ctx.lineTo(hunterPos.x, groundY + 5);
            ctx.moveTo(monkeyStartPos.x, groundY - 5);
            ctx.lineTo(monkeyStartPos.x, groundY + 5);
            ctx.stroke();
            
            // Label
            ctx.textAlign = 'center';
            ctx.fillText(`Distance: ${monkeyDist}m`, (hunterPos.x + monkeyStartPos.x) / 2, groundY - 8);

            // Draw Height Line (Vertical)
            // Draw slightly to the right of the monkey so it doesn't overlap trails too much
            const lineX = monkeyStartPos.x + 40; 
            ctx.beginPath();
            ctx.moveTo(lineX, monkeyStartPos.y);
            ctx.lineTo(lineX, hunterPos.y);
            ctx.stroke();

            // Ticks
            ctx.beginPath();
            ctx.moveTo(lineX - 5, monkeyStartPos.y);
            ctx.lineTo(lineX + 5, monkeyStartPos.y);
            ctx.moveTo(lineX - 5, hunterPos.y);
            ctx.lineTo(lineX + 5, hunterPos.y);
            ctx.stroke();

            // Label
            ctx.save();
            ctx.translate(lineX + 15, (monkeyStartPos.y + hunterPos.y) / 2);
            ctx.rotate(Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText(`Height: ${monkeyHeight}m`, 0, 0);
            ctx.restore();

            ctx.restore();
        }

        function drawHunter() {
            const size = 40;
            ctx.save();
            ctx.translate(hunterPos.x, hunterPos.y);
            
            // Rotation based on current Angle state
            ctx.rotate(-currentAngleRad); // Negative because canvas Y is down

            // Cannon Barrel
            ctx.fillStyle = '#475569';
            ctx.fillRect(0, -10, 60, 20);
            
            // Cannon Rim
            ctx.fillStyle = '#334155';
            ctx.fillRect(55, -12, 10, 24);

            ctx.restore();

            // Base/Wheel
            ctx.fillStyle = '#1e293b';
            ctx.beginPath();
            ctx.arc(hunterPos.x, hunterPos.y, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Label
            ctx.fillStyle = '#cbd5e1'; 
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText("HUNTER", hunterPos.x, hunterPos.y + 35);
        }

        function drawMonkey(x, y) {
            // Draw Target/Monkey
            ctx.save();
            ctx.translate(x, y);

            // Body
            ctx.fillStyle = '#ef4444'; // Red 500
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();
            
            // Face detail (simple)
            ctx.fillStyle = '#fca5a5'; // Red 200
            ctx.beginPath();
            ctx.arc(0, 2, 14, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#7f1d1d';
            ctx.beginPath();
            ctx.arc(-5, -2, 3, 0, Math.PI * 2);
            ctx.arc(5, -2, 3, 0, Math.PI * 2);
            ctx.fill();

            // Mouth
            ctx.beginPath();
            ctx.arc(0, 6, 4, 0, Math.PI, false);
            ctx.stroke();

            ctx.restore();
        }

        // Listeners
        fireBtn.addEventListener('click', startSimulation);
        resetBtn.addEventListener('click', resetSimulation);
        slowMotionCheck.addEventListener('change', () => {
             // Real-time toggle support not needed for simple sim, takes effect next frame or fire
        });
        showTrailsCheck.addEventListener('change', draw);
        showSightCheck.addEventListener('change', draw);

        // Initial setup
        resize();
        // Trigger one update to set values correctly
        updateValues();

    </script>
</body>
</html>