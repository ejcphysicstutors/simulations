<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resultant Gravitational Field</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        .ejc-credit-banner {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            color: white;
            padding: 12px 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            position: sticky;
            top: 0;
            z-index: 10000;
        }
        
        .ejc-credit-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .ejc-credit-title {
            font-size: 16px;
            font-weight: 600;
        }
        
        .ejc-credit-author {
            font-size: 14px;
            opacity: 0.95;
        }
        
        .ejc-credit-author strong {
            font-weight: 600;
            color: #fbbf24;
        }
    </style>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark Gray background */
            color: #d1d5db; /* Light gray text */
        }
        .card {
            background-color: #1f2937; /* Gray-800 */
            border-radius: 0.75rem;
            border: 1px solid #374151; /* Gray-700 */
            padding: 1.5rem;
            transition: all 0.3s ease-in-out;
        }
        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #60a5fa; /* Light Blue */
            margin-bottom: 1rem;
        }
        .control-label {
            font-weight: 500;
            color: #9ca3af; /* Gray-400 */
        }
        .value-display {
            font-weight: 700;
            font-size: 1.1rem;
            color: #e5e7eb; /* Gray-200 */
        }
        .result-box {
            background-color: #374151; /* Gray-700 */
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-top: 1.5rem;
            text-align: center;
        }
        .result-label {
            font-size: 1.1rem;
            font-weight: 500;
            color: #9ca3af;
        }
        .result-value {
            font-family: 'Courier New', Courier, monospace;
            font-weight: 700;
            font-size: 2rem;
            color: #f9fafb; /* Gray-50 */
            margin-top: 0.5rem;
        }
        input[type='range'] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #4b5563; /* Gray-600 */
            border-radius: 5px;
            outline: none;
        }
        input[type='range']::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #3b82f6; /* Blue-500 */
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid #1f2937; /* Gray-800 */
        }
        input[type='range']::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid #1f2937;
        }
        #gravityCanvas {
            background-color: #000;
            border-radius: 0.5rem;
            width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
    <div class="ejc-credit-banner">
        <div class="ejc-credit-content">
            <div class="ejc-credit-title">Resultant Gravitational Field</div>
            <div class="ejc-credit-author">Created by <strong>Seetoh Huixia</strong> | EJC Physics</div>
        </div>
    </div>
    
    <div class="ejc-simulation-container">
        

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-blue-400">Gravitational Field Simulation</h1>
            <p class="text-md md:text-lg text-gray-400 mt-2">Visualizing Newton's Law of Universal Gravitation</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Main Visualization -->
            <div class="lg:col-span-2 card">
                <h2 class="card-title">Gravitational Field Visualization</h2>
                <canvas id="gravityCanvas" width="800" height="500"></canvas>
            </div>

            <!-- Controls and Data -->
            <div class="card">
                <h2 class="card-title">Controls</h2>
                <div class="space-y-6">
                    <div>
                        <label for="mass1Slider" class="control-label">Mass 1 (m?)</label>
                        <input id="mass1Slider" type="range" min="1" max="1000" value="200">
                        <p class="value-display text-right"><span id="mass1Value">200</span> x 10?? kg</p>
                    </div>
                    <div>
                        <label for="mass2Slider" class="control-label">Mass 2 (m?)</label>
                        <input id="mass2Slider" type="range" min="1" max="1000" value="500">
                        <p class="value-display text-right"><span id="mass2Value">500</span> x 10?? kg</p>
                    </div>
                    <div>
                        <label for="distanceSlider" class="control-label">Distance (r)</label>
                        <input id="distanceSlider" type="range" min="100" max="500" value="300">
                        <p class="value-display text-right"><span id="distanceValue">300</span> km</p>
                    </div>
                </div>

                <div class="result-box">
                    <p class="result-label">Gravitational Force (F)</p>
                    <p id="forceValue" class="result-value">74.1 N</p>
                </div>
            </div>
        </div>

        <!-- Explanation Card -->
        <div class="card mt-6">
            <h2 class="card-title">Key Concepts (H2 Physics)</h2>
            <div class="space-y-4 text-gray-300">
                <p><strong>Newton's Law of Universal Gravitation:</strong> Any two point masses attract each other with a force that is directly proportional to the product of their masses and inversely proportional to the square of the distance between their centers.</p>
                <div class="bg-gray-800 p-4 rounded-lg text-center">
                    <p class="text-lg font-mono text-blue-300">F = G * (m? * m?) / r?</p>
                </div>
                <ul class="list-disc list-inside ml-4 space-y-2">
                    <li><strong class="text-blue-300">F</strong> is the magnitude of the gravitational force between the two masses.</li>
                    <li><strong class="text-blue-300">G</strong> is the universal gravitational constant, approximately 6.674 ? 10??? N?m?/kg?.</li>
                    <li><strong class="text-blue-300">m?</strong> and <strong class="text-blue-300">m?</strong> are the two masses.</li>
                    <li><strong class="text-blue-300">r</strong> is the distance between the centers of the two masses.</li>
                </ul>
                <p><strong>Gravitational Field Lines:</strong> The lines on the canvas represent the path a small test mass would follow. The arrows indicate the direction of the gravitational force. The density of the lines indicates the strength of the field?where lines are closer together, the gravitational pull is stronger.</p>
            </div>
        </div>
         <footer class="text-center mt-8 text-sm text-gray-500">
            <p>A simulation to aid in the understanding of gravitational concepts.</p>
        </footer>
    </div>

    <script>
        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('gravityCanvas');
        const ctx = canvas.getContext('2d');

        const mass1Slider = document.getElementById('mass1Slider');
        const mass2Slider = document.getElementById('mass2Slider');
        const distanceSlider = document.getElementById('distanceSlider');

        const mass1ValueEl = document.getElementById('mass1Value');
        const mass2ValueEl = document.getElementById('mass2Value');
        const distanceValueEl = document.getElementById('distanceValue');
        const forceValueEl = document.getElementById('forceValue');

        // --- CONSTANTS AND STATE ---
        const G = 6.674e-11;
        const MASS_SCALE = 1e10; // kg
        const DISTANCE_SCALE = 1e3; // meters (for km)

        let state = {
            m1: 200 * MASS_SCALE,
            m2: 500 * MASS_SCALE,
            r: 300 * DISTANCE_SCALE,
            force: 0
        };

        // --- CALCULATION ---
        function calculateForce() {
            state.m1 = mass1Slider.value * MASS_SCALE;
            state.m2 = mass2Slider.value * MASS_SCALE;
            state.r = distanceSlider.value * DISTANCE_SCALE;

            if (state.r > 0) {
                state.force = (G * state.m1 * state.m2) / (state.r * state.r);
            } else {
                state.force = 0;
            }
        }

        // --- DRAWING ---
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const pixelDistance = distanceSlider.value;

            // Positions of masses
            const x1 = centerX - pixelDistance / 2;
            const x2 = centerX + pixelDistance / 2;
            const y = centerY;

            // Draw continuous field lines
            drawFieldLines(x1, y, state.m1, x2, y, state.m2);

            // Draw masses on top of the lines
            drawMass(x1, y, state.m1, 'm?');
            drawMass(x2, y, state.m2, 'm?');
        }

        function drawMass(x, y, mass, label) {
            // Radius is proportional to cube root of mass to show volume
            const radius = Math.cbrt(mass / MASS_SCALE) * 2 + 5;
            
            const gradient = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, radius * 0.1, x, y, radius);
            gradient.addColorStop(0, 'rgba(147, 197, 253, 1)'); // Light blue
            gradient.addColorStop(1, 'rgba(59, 130, 246, 1)'); // Darker blue

            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.font = '16px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x, y);
        }
        
        // Helper function to get the gravitational field vector at a point
        function getGravitationalField(px, py, x1, y1, m1, x2, y2, m2) {
            const dx1 = x1 - px;
            const dy1 = y1 - py;
            const r1Sq = dx1 * dx1 + dy1 * dy1;
            const r1 = Math.sqrt(r1Sq);

            const dx2 = x2 - px;
            const dy2 = y2 - py;
            const r2Sq = dx2 * dx2 + dy2 * dy2;
            const r2 = Math.sqrt(r2Sq);

            let g1x = 0, g1y = 0, g2x = 0, g2y = 0;

            if (r1 > 1) {
                const g1 = (G * m1) / r1Sq;
                g1x = g1 * (dx1 / r1);
                g1y = g1 * (dy1 / r1);
            }

            if (r2 > 1) {
                const g2 = (G * m2) / r2Sq;
                g2x = g2 * (dx2 / r2);
                g2y = g2 * (dy2 / r2);
            }

            return { gx: g1x + g2x, gy: g1y + g2y };
        }
        
        // Function to draw continuous field lines with arrows in the middle
        function drawFieldLines(x1, y1, m1, x2, y2, m2) {
            const numLinesPerSide = 10;
            const stepSize = 5;
            const maxSteps = 250;

            const startPoints = [];
            for (let i = 0; i < numLinesPerSide; i++) {
                startPoints.push({ x: (canvas.width / numLinesPerSide) * (i + 0.5), y: 1 });
                startPoints.push({ x: (canvas.width / numLinesPerSide) * (i + 0.5), y: canvas.height - 1 });
            }
            const verticalLineCount = Math.round(numLinesPerSide * (canvas.height / canvas.width));
            for (let i = 0; i < verticalLineCount; i++) {
                startPoints.push({ x: 1, y: (canvas.height / verticalLineCount) * (i + 0.5) });
                startPoints.push({ x: canvas.width - 1, y: (canvas.height / verticalLineCount) * (i + 0.5) });
            }

            const r1_body = Math.cbrt(m1 / MASS_SCALE) * 2 + 5;
            const r2_body = Math.cbrt(m2 / MASS_SCALE) * 2 + 5;

            startPoints.forEach(p => {
                const pathPoints = [];
                let currentX = p.x;
                let currentY = p.y;
                pathPoints.push({ x: currentX, y: currentY });

                // 1. Calculate and store the entire path first
                for (let step = 0; step < maxSteps; step++) {
                    const field = getGravitationalField(currentX, currentY, x1, y1, m1, x2, y2, m2);
                    const magnitude = Math.sqrt(field.gx * field.gx + field.gy * field.gy);

                    if (magnitude === 0) break;

                    const vx = field.gx / magnitude;
                    const vy = field.gy / magnitude;

                    const nextX = currentX + stepSize * vx;
                    const nextY = currentY + stepSize * vy;
                    
                    pathPoints.push({ x: nextX, y: nextY });
                    currentX = nextX;
                    currentY = nextY;

                    const d1 = Math.sqrt(Math.pow(currentX - x1, 2) + Math.pow(currentY - y1, 2));
                    const d2 = Math.sqrt(Math.pow(currentX - x2, 2) + Math.pow(currentY - y2, 2));

                    if (d1 < r1_body || d2 < r2_body || currentX < 0 || currentX > canvas.width || currentY < 0 || currentY > canvas.height) {
                        break;
                    }
                }

                // 2. Draw the calculated path
                if (pathPoints.length > 1) {
                    ctx.strokeStyle = 'rgba(255, 255, 100, 0.6)';
                    ctx.lineWidth = 1.2;
                    ctx.beginPath();
                    ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
                    for (let i = 1; i < pathPoints.length; i++) {
                        ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
                    }
                    ctx.stroke();
                }

                // 3. Draw the arrowhead in the middle of the path
                if (pathPoints.length > 2) {
                    const midIndex = Math.floor(pathPoints.length / 2);
                    const p1 = pathPoints[midIndex];
                    const p2 = pathPoints[midIndex + 1];

                    if (p1 && p2) {
                        const vx = p2.x - p1.x;
                        const vy = p2.y - p1.y;
                        const angle = Math.atan2(vy, vx);
                        const arrowSize = 8;
                        const arrowAngle = Math.PI / 6;

                        ctx.fillStyle = 'rgba(255, 255, 100, 0.9)';
                        ctx.beginPath();
                        ctx.moveTo(p2.x, p2.y);
                        ctx.lineTo(
                            p2.x - arrowSize * Math.cos(angle - arrowAngle),
                            p2.y - arrowSize * Math.sin(angle - arrowAngle)
                        );
                        ctx.lineTo(
                            p2.x - arrowSize * Math.cos(angle + arrowAngle),
                            p2.y - arrowSize * Math.sin(angle + arrowAngle)
                        );
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            });
        }


        // --- UPDATE UI ---
        function updateUI() {
            mass1ValueEl.textContent = mass1Slider.value;
            mass2ValueEl.textContent = mass2Slider.value;
            distanceValueEl.textContent = distanceSlider.value;
            forceValueEl.textContent = `${state.force.toExponential(2)} N`;
        }

        // --- MAIN LOOP ---
        function loop() {
            calculateForce();
            updateUI();
            draw();
        }

        // --- EVENT LISTENERS ---
        mass1Slider.addEventListener('input', loop);
        mass2Slider.addEventListener('input', loop);
        distanceSlider.addEventListener('input', loop);
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            const aspectRatio = 800 / 500;
            canvas.width = container.clientWidth;
            canvas.height = container.clientWidth / aspectRatio;
            loop();
        }
        
        window.addEventListener('resize', resizeCanvas);

        // --- INITIALIZATION ---
        window.onload = () => {
            resizeCanvas();
        };
    </script>

    </div>
    
    <script src="https://cdn.tailwindcss.com"></script>
<script>
        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('gravityCanvas');
        const ctx = canvas.getContext('2d');

        const mass1Slider = document.getElementById('mass1Slider');
        const mass2Slider = document.getElementById('mass2Slider');
        const distanceSlider = document.getElementById('distanceSlider');

        const mass1ValueEl = document.getElementById('mass1Value');
        const mass2ValueEl = document.getElementById('mass2Value');
        const distanceValueEl = document.getElementById('distanceValue');
        const forceValueEl = document.getElementById('forceValue');

        // --- CONSTANTS AND STATE ---
        const G = 6.674e-11;
        const MASS_SCALE = 1e10; // kg
        const DISTANCE_SCALE = 1e3; // meters (for km)

        let state = {
            m1: 200 * MASS_SCALE,
            m2: 500 * MASS_SCALE,
            r: 300 * DISTANCE_SCALE,
            force: 0
        };

        // --- CALCULATION ---
        function calculateForce() {
            state.m1 = mass1Slider.value * MASS_SCALE;
            state.m2 = mass2Slider.value * MASS_SCALE;
            state.r = distanceSlider.value * DISTANCE_SCALE;

            if (state.r > 0) {
                state.force = (G * state.m1 * state.m2) / (state.r * state.r);
            } else {
                state.force = 0;
            }
        }

        // --- DRAWING ---
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const pixelDistance = distanceSlider.value;

            // Positions of masses
            const x1 = centerX - pixelDistance / 2;
            const x2 = centerX + pixelDistance / 2;
            const y = centerY;

            // Draw continuous field lines
            drawFieldLines(x1, y, state.m1, x2, y, state.m2);

            // Draw masses on top of the lines
            drawMass(x1, y, state.m1, 'm?');
            drawMass(x2, y, state.m2, 'm?');
        }

        function drawMass(x, y, mass, label) {
            // Radius is proportional to cube root of mass to show volume
            const radius = Math.cbrt(mass / MASS_SCALE) * 2 + 5;
            
            const gradient = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, radius * 0.1, x, y, radius);
            gradient.addColorStop(0, 'rgba(147, 197, 253, 1)'); // Light blue
            gradient.addColorStop(1, 'rgba(59, 130, 246, 1)'); // Darker blue

            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.font = '16px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x, y);
        }
        
        // Helper function to get the gravitational field vector at a point
        function getGravitationalField(px, py, x1, y1, m1, x2, y2, m2) {
            const dx1 = x1 - px;
            const dy1 = y1 - py;
            const r1Sq = dx1 * dx1 + dy1 * dy1;
            const r1 = Math.sqrt(r1Sq);

            const dx2 = x2 - px;
            const dy2 = y2 - py;
            const r2Sq = dx2 * dx2 + dy2 * dy2;
            const r2 = Math.sqrt(r2Sq);

            let g1x = 0, g1y = 0, g2x = 0, g2y = 0;

            if (r1 > 1) {
                const g1 = (G * m1) / r1Sq;
                g1x = g1 * (dx1 / r1);
                g1y = g1 * (dy1 / r1);
            }

            if (r2 > 1) {
                const g2 = (G * m2) / r2Sq;
                g2x = g2 * (dx2 / r2);
                g2y = g2 * (dy2 / r2);
            }

            return { gx: g1x + g2x, gy: g1y + g2y };
        }
        
        // Function to draw continuous field lines with arrows in the middle
        function drawFieldLines(x1, y1, m1, x2, y2, m2) {
            const numLinesPerSide = 10;
            const stepSize = 5;
            const maxSteps = 250;

            const startPoints = [];
            for (let i = 0; i < numLinesPerSide; i++) {
                startPoints.push({ x: (canvas.width / numLinesPerSide) * (i + 0.5), y: 1 });
                startPoints.push({ x: (canvas.width / numLinesPerSide) * (i + 0.5), y: canvas.height - 1 });
            }
            const verticalLineCount = Math.round(numLinesPerSide * (canvas.height / canvas.width));
            for (let i = 0; i < verticalLineCount; i++) {
                startPoints.push({ x: 1, y: (canvas.height / verticalLineCount) * (i + 0.5) });
                startPoints.push({ x: canvas.width - 1, y: (canvas.height / verticalLineCount) * (i + 0.5) });
            }

            const r1_body = Math.cbrt(m1 / MASS_SCALE) * 2 + 5;
            const r2_body = Math.cbrt(m2 / MASS_SCALE) * 2 + 5;

            startPoints.forEach(p => {
                const pathPoints = [];
                let currentX = p.x;
                let currentY = p.y;
                pathPoints.push({ x: currentX, y: currentY });

                // 1. Calculate and store the entire path first
                for (let step = 0; step < maxSteps; step++) {
                    const field = getGravitationalField(currentX, currentY, x1, y1, m1, x2, y2, m2);
                    const magnitude = Math.sqrt(field.gx * field.gx + field.gy * field.gy);

                    if (magnitude === 0) break;

                    const vx = field.gx / magnitude;
                    const vy = field.gy / magnitude;

                    const nextX = currentX + stepSize * vx;
                    const nextY = currentY + stepSize * vy;
                    
                    pathPoints.push({ x: nextX, y: nextY });
                    currentX = nextX;
                    currentY = nextY;

                    const d1 = Math.sqrt(Math.pow(currentX - x1, 2) + Math.pow(currentY - y1, 2));
                    const d2 = Math.sqrt(Math.pow(currentX - x2, 2) + Math.pow(currentY - y2, 2));

                    if (d1 < r1_body || d2 < r2_body || currentX < 0 || currentX > canvas.width || currentY < 0 || currentY > canvas.height) {
                        break;
                    }
                }

                // 2. Draw the calculated path
                if (pathPoints.length > 1) {
                    ctx.strokeStyle = 'rgba(255, 255, 100, 0.6)';
                    ctx.lineWidth = 1.2;
                    ctx.beginPath();
                    ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
                    for (let i = 1; i < pathPoints.length; i++) {
                        ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
                    }
                    ctx.stroke();
                }

                // 3. Draw the arrowhead in the middle of the path
                if (pathPoints.length > 2) {
                    const midIndex = Math.floor(pathPoints.length / 2);
                    const p1 = pathPoints[midIndex];
                    const p2 = pathPoints[midIndex + 1];

                    if (p1 && p2) {
                        const vx = p2.x - p1.x;
                        const vy = p2.y - p1.y;
                        const angle = Math.atan2(vy, vx);
                        const arrowSize = 8;
                        const arrowAngle = Math.PI / 6;

                        ctx.fillStyle = 'rgba(255, 255, 100, 0.9)';
                        ctx.beginPath();
                        ctx.moveTo(p2.x, p2.y);
                        ctx.lineTo(
                            p2.x - arrowSize * Math.cos(angle - arrowAngle),
                            p2.y - arrowSize * Math.sin(angle - arrowAngle)
                        );
                        ctx.lineTo(
                            p2.x - arrowSize * Math.cos(angle + arrowAngle),
                            p2.y - arrowSize * Math.sin(angle + arrowAngle)
                        );
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            });
        }


        // --- UPDATE UI ---
        function updateUI() {
            mass1ValueEl.textContent = mass1Slider.value;
            mass2ValueEl.textContent = mass2Slider.value;
            distanceValueEl.textContent = distanceSlider.value;
            forceValueEl.textContent = `${state.force.toExponential(2)} N`;
        }

        // --- MAIN LOOP ---
        function loop() {
            calculateForce();
            updateUI();
            draw();
        }

        // --- EVENT LISTENERS ---
        mass1Slider.addEventListener('input', loop);
        mass2Slider.addEventListener('input', loop);
        distanceSlider.addEventListener('input', loop);
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            const aspectRatio = 800 / 500;
            canvas.width = container.clientWidth;
            canvas.height = container.clientWidth / aspectRatio;
            loop();
        }
        
        window.addEventListener('resize', resizeCanvas);

        // --- INITIALIZATION ---
        window.onload = () => {
            resizeCanvas();
        };
    </script>
</body>
</html>